{"pages":[{"text":"Objectives Explain how the shell relates to the keyboard, the screen, the operating system, and users' programs. Explain when and why command-line interfaces should be used instead of graphical interfaces. Nelle Nemo, a marine biologist, has just returned from a six-month survey of the North Pacific Gyre , where she has been sampling gelatinous marine life in the Great Pacific Garbage Patch . She has 1520 samples in all, and now needs to: Run each sample through an assay machine that will measure the relative abundance of 300 different proteins. The machine's output for a single sample is a file with one line for each protein. Calculate statistics for each of the proteins separately using a program her supervisor wrote called goostat . Compare the statistics for each protein with corresponding statistics for each other protein using a program one of the other graduate students wrote called goodiff . Write up. Her supervisor would really like her to do this by the end of the month so that her paper can appear in an upcoming special issue of Aquatic Goo Letters . It takes about half an hour for the assay machine to process each sample. The good news is, it only takes two minutes to set each one up. Since her lab has eight assay machines that she can use in parallel, this step will \"only\" take about two weeks. The bad news is that if she has to run goostat and goodiff by hand, she'll have to enter filenames and click \"OK\" 45,150 times (300 runs of goostat , plus 300\u00d7299/2 runs of goodiff ). At 30 seconds each, that will take more than two weeks. Not only would she miss her paper deadline, the chances of her typing all of those commands right are practically zero. The next few lessons will explore what she should do instead. More specifically, they explain how she can use a command shell to automate the repetitive steps in her processing pipeline so that her computer can work 24 hours a day while she writes her paper. As a bonus, once she has put a processing pipeline together, she will be able to use it again whenever she collects more data. What and Why At a high level, computers do four things: run programs; store data; communicate with each other; and interact with us. They can do the last of these in many different ways, including direct brain-computer links and speech interfaces. Since these are still in their infancy, most of us use windows, icons, mice, and pointers. These technologies didn't become widespread until the 1980s, but their roots go back to Doug Engelbart's work in the 1960s, which you can see in what has been called \" The Mother of All Demos \". Going back even further, the only way to interact with early computers was to rewire them. But in between, from the 1950s to the 1980s, most people used line printers. These devices only allowed input and output of the letters, numbers, and punctuation found on a standard keyboard, so programming languages and interfaces had to be designed around that constraint. This kind of interface is called a command-line interface , or CLI, to distinguish it from the graphical user interface , or GUI, that most people now use. The heart of a CLI is a read-evaluate-print loop , or REPL: when the user types a command and then presses the enter (or return) key, the computer reads it, executes it, and prints its output. The user then types another command, and so on until the user logs off. This description makes it sound as though the user sends commands directly to the computer, and the computer sends output directly to the user. In fact, there is usually a program in between called a command shell . What the user types goes into the shell; it figures out what commands to run and orders the computer to execute them. A shell is a program like any other. What's special about it is that its job is to run other programs rather than to do calculations itself. The most popular Unix shell is Bash, the Bourne Again SHell (so-called because it's derived from a shell written by Stephen Bourne\u2014this is what passes for wit among programmers). Bash is the default shell on most modern implementations of Unix, and in most packages that provide Unix-like tools for Windows. Using Bash or any other shell sometimes feels more like programming than like using a mouse. Commands are terse (often only a couple of characters long), their names are frequently cryptic, and their output is lines of text rather than something visual like a graph. On the other hand, the shell allows us to combine existing tools in powerful ways with only a few keystrokes and to set up pipelines to handle large volumes of data automatically. In addition, the command line is often the easiest way to interact with remote machines. As clusters and cloud computing become more popular for scientific data crunching, being able to drive them is becoming a necessary skill. Key Points A shell is a program whose primary purpose is to read commands and run other programs. The shell's main advantages are its high action-to-keystroke ratio, its support for automating repetitive tasks, and that it can be used to access networked machines. The shell's main disadvantages are its primarily textual nature and how cryptic its commands and operation can be.","tags":"shell","loc":"/shell/introducing-the-shell.html","title":"Introducing the Shell"},{"text":"Here's the dream: Computers have revolutionized research, and that revolution is only beginning. Every day, scientists and engineers all over the world use them to study things that are too big, too small, too fast, too slow, too expensive, too dangerous, or just too hard to study any other way. Now here's the reality: Every day, scientists and engineers all over the world waste time wrestling with computers. Tasks that should take a few moments take hours or days, and many things never work at all. And even when things do work, most scientists have no idea how reliable their results are. Most of the pain that researchers feel stems from not knowing how to develop software systematically, how to tell if their programs are working correctly, how to share their work with others (except by mailing files to one another), or how to keep track of what they've done. This sorry state of affairs persists for four reasons: No room, no time. Everybody's curriculum is full\u2014there's simply not space to add more about computing without dropping something else. No standards. Reviewers and granting agencies don't check whether software is correct, ask how long it took to write, or count it toward tenure, so there's no incentive for scientists to do better. The blind leading the blind. Senior researchers can't teach the next generation how to do things that they don't know how to do themselves. The cult of big iron. Attention and funding mostly goes to things that politicians and university presidents can brag about on opening day, rather than to the basic skills that almost everyone uses. Our goal is to show scientists and engineers how to do more in less time and with less pain. Our lessons have been used by more than four thousand learners in over a hundred two-day workshops since the spring of 2010. Here's how they can help: If you've ever overwritten the wrong file, we'll show you how to use version control. If you've ever spent hours typing the same commands over and over again, we'll show you how to automate those tasks using simple scripts. If you've ever spent an afternoon trying to figure out what the program you wrote last week actually does, we'll show you how to break your code into modules that you can read, debug, and improve piece by piece. If you've ever spent days copying and pasting data in text files and spreadsheets, we'll show you how a database can do the work for you. About Us Software Carpentry is an open source project. Our instructors are volunteers, and all of our lessons are freely available under the Creative Commons - Attribution License , so you can re-use and re-mix them however you want so long as you cite us as the original source. Like all volunteer projects, Software Carpentry needs your help to grow. If you find a bug, please file a report in our GitHub repo . If you would like to host a workshop, please get in touch ; if you'd like to teach, we run an instructor training course ; and if you'd like to write lessons or exercises, please let us know . To find out more, please visit the http://software-carpentry.org or read these papers or our most popular blog posts . Acknowledgments Software Carpentry has been made possible by the generous support of: Continuum Analytics Indiana University Lawrence Berkeley National Laboratory Los Alamos National Laboratory MathWorks Michigan State University Microsoft MITACS The Mozilla Foundation The Python Software Foundation Queen Mary University of London Scimatic Software SciNet SHARCNET The Alfred P. Sloan Foundation The Space Telescope Science Institute The UK Meteorological Office The University of Alberta The University Consortium for Atmospheric Research The University of Toronto Special thanks go to Brent Gorda, who helped build and teach the first version of this course. This book is dedicated to Betty Jennings , Betty Snyder , Fran Bilas , Kay McNulty , Marlyn Wescoff , and Ruth Lichterman , the original programmers of the ENIAC .","tags":"lessons","loc":"/lessons/introduction.html","title":"Introduction"},{"text":"The Unix shell has been around longer than most of its users have been alive. It has survived so long because it's a power tool that allows people to do complex things with just a few keystrokes. More importantly, it helps them combine existing programs in new ways and automate repetitive tasks so that they don't have to type the same things over and over again. Introducing the Shell Files and Directories Creating Things Pipes and Filters Loops Shell Scripts Finding Things","tags":"shell","loc":"/shell/the-unix-shell.html","title":"The Unix Shell"},{"text":"This is the content of my example news item.","tags":"Python","loc":"/news/example-news-item.html","title":"Example news item"}]}